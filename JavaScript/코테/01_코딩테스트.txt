1. 온라인 개발 환경
- https://replit.com
- 런타임환경 : Node.js 
- name : index.js

2. 시험환경
- 2~5시간
- 정렬, 구현, DFS/BFS(탐색), 완전탐색, 탐욕알고리즘 유형

3. 시간복잡도
- 시간복잡도는 알고리즘의 성능을 나타내는 척도
- 특정한 크기의 입력에 대하여 알고리즘의 수행 시간 분석
- 동일한 기능을 수행하는 알고리즘이 있다면, 일반적으로 복잡도가
  낮을 수록 우수하다.

4. 빅오(Big-O Notation)
- 가장 빠르게 증가하는 항만을 고려하는 표기법
- 함수의 상한을 나타낸다.
- 예를 들어어 연산횟수가 
   3N^3 + 5N^2 + 1,000,000 인 알고리즘이 있다고 가정
   (N이 1,000일 때 3N^3은 10억이되며 다른 항은 무의미..)
- N이 증가함에 따라 3N^3을 제외한 다른 항의 영향력은 작아진다.
- Big-O 표기법에서는 차수가 가장 큰 항에서 계수를 제외하여
  O(N^3)으로 표현된다.

5. 좋음(Better)  ---------------------> 나쁨(Worse)
   O(1)   O(logN) O(N)  O(NlogN) O(N^2) O(N^3) O(2^N)

- O(1) : 상수시간
- O(logN) : 로그시간(이분탐색 등..)
- O(N) : 선형시간(배열 검색)
- O(NlogN) : 로그선형시간(병합, 퀵, 힙정렬)
- O(N^2) : 이차시간
- O(N^3) : 3차시간
- O(2^N) : 지수시간

    ▷ log 시간은 값이 커질수록 상수시간에 가까워 진다.
        밑수 2 지수 N이 백만 --> 2의 20제곱이 백만.. 
        --> 그러므로 N이 백만일 때 실 값은 20 밖에 안되므로
        거의 로그분포는 상수에 가깝다.
    ※ 엑셀 로그함수 : =LOG(1000000,2)  ===> 19.9316

6. 시간복잡도 예시
ⓐ N개의 데이터 합을 계산하는 프로그램 예제(N = 5)
let array = [3 ,5, 1, 2, 4];
let sum;
for(let i=0; i<array.length; i++){
    sum = sum + array[i];
}
console.log(sum);

- N개 데이터를 순회하며 합을 누적하므로 N번 수행 : N에 비례
- 시간 복잡도 : O(N)

ⓑ 2중 반복문을 이용하는 프로그램 예제(N = 5)
let array = [3 ,5, 1, 2, 4];
for(let i=0; i<array.length; i++){
    for(let j=0; j<array.length; j++){
        let tmp = array[i] * array[j];
        console.log(tmp);
    }
}

- 시간복잡도 : O(N^2)
- 소스코드 내부적으로 다른 함수를 호출한다면 그 함수도 고려해야 함.
  즉, 모든 2중 반복문이 O(N^2)인 것은 아니다.

7. 알고리즘 설계 Tip
- JavaScript 기준으로 1억번 연산 수행시 1~5초 가량의 시간 소요
- O(N^3)의 알고리즘 설계 시, N 값이 5,000이 넘는 경우
- 이때는 약 12억번의 연산이 수행되게 됨.
- 그럼... 대략 10초가 넘어가는 꼴이므로 적절하지 않은 알고리즘 임.
- 코딩 테스트 문제에서 시간 제한은 통상 1~5초 가량이다.

8. 역으로 알로리즘 설계하기
- 시간제한 요구사항 확인
- 시간 제한이 1초인 경우
ⓐ N의 범위가 500인 경우 : O(N^3)
ⓑ N의 범위가 2,000인 경우 : O(N^2)
ⓒ N의 범위가 100,000인 경우 : O(NlogN)
ⓓ N의 범위가 10,000,000인 경우 : O(N)